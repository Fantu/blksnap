.. SPDX-License-Identifier: GPL-2.0

================================================
Модуль для создания снапшотов блочных устройств
================================================

Introduction
============

На первый взгляд, в идее создания снапшотов для блочных устройств нет новизны.
В ядре Linux уже есть механизмы для создания снапшотов.
В состав Device Mapper входит dm-snap, который позволяет создавать снапшоты блочных устройств.
BTRFS поддерживает снапшоты на уровне файловой системы.
Однако у обоих этих вариантов есть недостатки, которые не позволяют использовать их как универсальное средство для создания резервных копий.

Недостатки Device Mapper:
 * На блочных устройствах должна быть LVM-разметка.
   Если при установке системы логические тома не были созданы, то dm-snap не может быть применён.
 * Для хранения изменений снапшота одного логического тома необходимо зарезервировать фиксированный диапазон секторов на зарезервированном пустом логическом томе.
   Во-первых, требуется, чтобы в системе было достаточно пространства, не занятого файловой системой, что на реальных серверах встечается редко.
   Во-вторых, как правило, необходимо создать снапшоты сразу для всех логических томов, что требует разделить между несколькими логическими томами это зарезервированное пространство.
   Можно разделить это пространство поровну либо пропорционально размеру. Но нагрузка на разные диски, как правило, распределена неравномерно.
   В результате, для одного из блочных устройств происходит переполнение снапшота, в то время как для других всё зарезервированное пространство может оставаться свободным.
   Это усложняет управление хранилищем изменений и делает практически невозможным создание согласованного снапшота нескольких логических томов.

Недостатки BTRFS:
 * Снапшоты создают неизменный образ именно файловой системы, а не блочного устройства. Такой снапшот применим только для файлового бэкапа.
 * При синхронизации сабволюма снапшота с сабволюмом резервной копии чтение различий приводит к произвольному доступу к блочному устройству, что приводит к снижению эффективности по сравнению с прямым копированием блочного устройства.
 * BTRFS позволяет получить инкрементальный бэкап [#btrfs_increment]_, но для этого необходимо удерживать на системе снапшот предыдущего цикла бэкапа, что приводит к чрезмерному потреблению дискового пространства.
 * При нехватке свободного пространства на файловой системе во время удержания снапшота новые данные не могут быть сохранены, что приводит к нарушению работы сервера.

Достоинства модуля blksnap:
 * Наличие трекера изменений.
 * Снапшот на уровне блочного устройства.
 * Динамическое выделение пространства для хранения изменеий.
 * Устойчивость к переполнению снапшота.
 * Согласованный снапшот нескольких блочных устройств.

Более подробное описание особенностей в разделе Features.

Перечисленный набор возможностей позволяет достигнуть ключевых целей средства резервного копирования:
 * Простота и универсальность использования.
 * Надёжность.
 * Минимальное потребление системных ресурсов при бэкапе.
 * Минимальное время восстановления или репликации системы целиком.

Features
========

Трекер изменений
----------------

Трекер изменений позволяет определить, какие блоки были изменены за время между последним созданным снапшотом и любым из предыдущих снапшотов.
Обладая картой изменений, достаточно произвести копирование только изменившихся блоков, а не перечитывать всё блочное устройтсво полностью.
Позволяет реализовывать логику как инкрементального, так и дифференциального бэкапа.
Инкрементальный бэкап критически важен для больших файловых хранилищ, размер которых может составлять сотни терабайт, а время полного резервного копирования которых может достигать более суток.
На таких серверах использование средств резервного копирования без трекера изменений становится фактически невозможным.

Снапшот на уровне блочного устройства
-------------------------------------

Снапшот на уровне блочного устройства позволяет упростить алгоритм резервного копирования и снизить потребление системных ресурсов.
Также он позволяет выполнять линейное чтение дискового простанства напрямую, что позволяет достигнуть максимальной скорости чтения при минимальном использовании процессорного времени.
При этом достигается универсальность создания снапшотов для любых блочных устройств вне зависимости от файловой системы, расположенной на них.
Исключением являются BTRFS, ZFS и кластерные файловые системы.

Динамическое выделение пространства для хранения изменений
---------------------------------------------------------

Для хранения изменений модуль не требует заранее зарезервированного диапазона блочного устройства.
Для хранения изменений снапшота может быть использован произвольный диапазон секторов на любом блочном устройстве.
Размер хранилища изменений может увеличиваться уже после создания снапшота путём добавления новых диапазонов секторов, в том числе на новых блочных устройтсвах.
Это позволяет создавать хранилище изменений в отдельных файлах на файловой системе и увеличивать хранилище изменений по мере необходимости.
Общее хранилище изменений для всех образов блочных устройств снапшота позволяет оптимизировать использование дискового пространства.
При этом поддерживается возможность зарезервировать хранилище изменений необходимого размера до создания снапшота.
Такая возможность может быть применима для высоконагруженных систем, для которых время аллокации новых диапазонов секторов может быть слишком длительным.

Устойчивость к переполнению снапшота
------------------------------------

Для создания образов снапшотов блочных устройств модуль хранит блоки оригинального блочного устройства, которые были изменены с момента снятия снапшота.
Для этого модуль перехватывает запросы на запись и считывает блоки, которые должны быть перезаписаны.
Такой алгоритм гарантирует сохранность данных оригинального блочного устройства в случае переполнения снапшота, и даже в случае непредсказуемых критических ошибкок.
Если возникает проблема во время резервного копирования, хранилище изменений освобождается, снапшот закрывается, резервная копия не создаётся, но сервер продолжает работать.

Согласованный снапшот нескольких блочных устройств
--------------------------------------------------

Снапшот создаётся одновременно для всех блочных устройств, для которых создаётся резервная копия, обеспечивая их согласованное состояние.


Algoritms
=========

Overview
--------

Модуль blksnap является фильтром блочного уровня. Он перехватывает все запросы на запись.
Подключение фильтра к блочному устройству выполняется при первом создании снапшота.
Трекер изменений отмечает все перезаписанные блоки.
Информация об истории изменений на блочном устройстве доступна во время удержания снапшота.
Модуль выполняет чтение блоков, которые должны быть перезаписаны, и сохраняет их в хранилище изменений.
При чтении из образа снапшота чтение выполняется либо из оригинального устройства, либо из хранилища изменений.

Трекер изменений
----------------

Для каждого блочного устройства создаётся карта трекера изменений.
Один байт этой карты соответствует одному блоку.
Размер блока задаётся параметрами модуля ``tracking_block_minimum_shift`` и ``tracking_block_maximum_count``.
Параметр ``tracking_block_minimum_shift`` ограничивает минимальный размер блока для трекинга, в то время как ``tracking_block_maximum_count`` определяет их максимальное допустимое количество.
Размер блока трекера изменений определяется в зависимости от размера блочного устройства при добавлении устройства под трекинг, то есть при первом снятии снапшота.
Размер блока должен быть степенью двойки.

Байт карты изменений хранит число от 0 до 255. Это номер снапшота, с момента создания которого были изменения в блоке.
При каждом создании снапшота номер текущего снапшота увеличивается на единицу.
Этот номер записывается в ячейку карты изменений при записи в блок.
Таким образом, зная номер одного из предыдущих снапшотов и номер последнего снапшота, можно определить по карте изменений, какие блоки были изменены.
Когда номер текущего изменения достигает максимального допустимого значения для карты в 255, при создании следующего снапшота карта изменений обнуляется, а номеру текущего снапшота присваивается значение 1.
Трекер изменений сбрасывается, и генерируется новый UUID — уникальный идентификатор поколения снапшотов.
Идентификатор поколения снапшотов позволяет выявлять, что был выполнен сброс трекинга изменений.

У карты изменений есть две копии. Одна копия активная, она отслеживает текущие изменения на блочном устройстве.
Вторая копия доступна для чтения на время, пока удерживается снапшот, и содержит историю до момента снятия снапшота.
Копии синхронизируются в момент создания снапшота.
После освобождения снапшота вторая копия карты не нужна, но она не освобождается, чтобы не выделять для неё память снова при следующем создании снапшота.

Копирование при записи
----------------------

Копирование данных выполняется блоками, точнее кусками. Термин "кусок" используется, чтобы не путать его с блоками трекера изменений и блоками ввода/вывода.
Кроме того, "кусок" в модуле blksnap означает примерно то же самое, что и "кусок" в модуле dm-snap.

Размер куска определяется параметрами модуля ``chunk_minimum_shift`` и ``chunk_maximum_count``.
Параметр ``chunk_minimum_shift`` ограничивает минимальный размер куска, в то время как ``chunk_maximum_count`` определяет их максимальное допустимое количество.
Размер куска определяется в зависимости от размера блочного устройства в момент снятия снапшота. Размер куска должен быть степенью двойки.
Один кусок описывается структурой ``struct chunk``. Для каждого блочного устройства создаётся массив структур.
Структура содержит всю необходимую информацию для копирования данных куска с оригинального блочного устройства в хранилище изменений.
Эта же информация позволяет отобразить образ снапшота. В структуре расположен семафор, позволяющий обеспечить синхронизацию потоков, обращающихся к одному куску.

У блочного уровня есть особенность. Если послать запрос на чтение, а вслед нему послать запрос на запись, то сначала может быть выполнена запись, а лишь затем чтение.
Поэтому алгоритм копирования при записи выполняется синхронно.
При перехвате запроса на запись выполнение этого запроса будет отложено до тех пор, пока не будут скопированы в хранилище изменений подверженные перезаписи куски.
Но если при перехвате запроса на запись оказывается, что записываемый диапазон секторов уже был скопирован в хранилище изменений, то запрос просто пропускается.

Такой алгоритм позволяет эффективно выполнять резервные копии систем с работающими на них Round Robin Database.
Такие базы способны несколько раз перезаписаться за время выполнения резервного копирования системы.
Конечно, ценность резервной копии данных RRD-системы мониторинга можно поставить под сомнение.
Однако часто стоит задача сделать резервную копию всей инфраструктуры предприятия целиком, чтобы в случае проблем восстановить или реплицировать её тоже целиком.

Но есть и недостаток. Так как при перезаписи хотя бы одного сектора производится копирование целого куска, возможна ситуация быстрого заполнения хранилища изменений при записи на блочное устройство данных маленькими порциями в случайном порядке.
Такая ситуация возможна при сильной фрагментации данных на файловой системе.
Но надо учитывать, что при такой фрагментации данных производительность систем, как правило, сильно деградирует.
Поэтому эта проблема не встречается на реальных серверах, хотя легко может быть создана искусственными тестами.

Хранилище изменений
-------------------

Хранилище изменений представляет собой пул областей дискового пространства и является общим для всех блочных устройств снапшота.
Поэтому нет необходимость распределять область хранения изменений между блочными устройствами, а само хранилище изменений может быть расположено на разных блочных устройствах.

Нет необходимости выделять сразу большое дисковое пространство перед снятием снапшота.
Уже во время удержания снапшота хранилище изменений может быть расширено.
Достаточно иметь свободное пространство на файловой системе.

Области дискового пространства можно аллоцировать на файловой системе с помощью fallocate(), а запросить расположение файла можно с помощью Fiemap Ioctl или Fibmap Ioctl.
К сожалению, не все файловые системы поддерживают работу этих механизмов, но самые распространённые XFS, EXT4 и BTRFS его поддерживают.
Для BTRFS требуется дополнительное преобразование виртуальных смещений в физические.

При удержании снапшота пользовательский процесс может опрашивать состояние модуля.
Когда свободное пространство в хранилище изменений уменьшается до порогового значения, модуль генерирует событие об этом.
Пользовательский процесс может подготовить новую область и передать её модулю для расширения хранилища изменений.
Пороговое значение определяется как половина от значения параметра модуля ``diff_storage_minimum``.

Если свободное пространство в хранилище изменений заканчивается, то генерируется событие о переполнении снапшота.
Такой снапшот считается повреждённым, а запросы на чтение к образам снапшотов будут завершаться с кодом ошибки.
Хранилище изменений сохраняет устаревшие данные, необходимые для образов снапшотов, поэтому при переполнении снапшота процесс резервного копирования прерывается, но система сохраняет свою работоспособность без потери данных.

How to use
==========

В зависимости от потребностей и выбранной лицензии можно выбрать разные варианты управления модулем:
 * Используя ioctl напрямую.
 * Используя статическую С++ библиотеку.
 * Используя консольный инструмент blksnap.

Иcпользование ioctl
-------------------

Модуль предоставляет заголовочный файл ``include/uapi/blksnap.h``.
В нём описаны все доступные ioctl и структуры для взаимодействия с модулем.
Каждый ioctl и структура подробно документированы.
Общий алгоритм вызова управляющих запросов примерно следующий:
 1. ``blk_snap_ioctl_snapshot_create`` инициирует процесс создания снапшота.
 2. ``blk_snap_ioctl_snapshot_append_storage`` позволяет добавить первый диапазон блоков для храниения изменений.
 3. ``blk_snap_ioctl_snapshot_take`` создаёт блочные устройства образов снапшотов блочных устройств.
 4. ``blk_snap_ioctl_snapshot_collect`` и ``blk_snap_ioctl_snapshot_collect_images`` позволяют сопоставить оригинальные блочные устройтсва и соответсвующие им образы снапшотов.
 5. Выполняется чтение образов снапшотов с блочных устройтсв, номера которых были получены при вызове ``blk_snap_ioctl_snapshot_collect_images``. Образы снапшотов поддерживают и операцию записи, поэтому перед резервным копированием можно монтировать файловую систему на образе снапшота и проводить необходимый препроцессинг.
 6. ``blk_snap_ioctl_tracker_collect`` и ``blk_snap_ioctl_tracker_read_cbt_map`` позволяют получить данные трекера изменений. Если в образ снапшота производилась запись, то трекер изменений учитывает это. Поэтому получать данные трекера необходимо после того, как операции записи были завершены.
 7. ``blk_snap_ioctl_snapshot_wait_event`` позволяет отслеживать состояние снапшотов и получать события о требовании расширения хранилища изменений или переполнении снапшота.
 8. Расширение хранилища изменений производится с помощью ``blk_snap_ioctl_snapshot_append_storage``.
 9. ``blk_snap_ioctl_snapshot_destroy`` освобождает снапшот.
 10. Если после создания резервной копии с данными выполняется постпроцессинг, изменяющий блоки резервной копии, неободимо помечать такие блоки как грязные в таблице трекера изменений. Для этого может быть использован ``blk_snap_ioctl_tracker_mark_dirty_blocks``.
 11. Есть возможность отключить трекер изменений от какого-либо блочного устройства с помощью ``blk_snap_ioctl_tracker_remove``.

Статическая С++ библиотека
--------------------------

Библиотека [#userspace_libs]_ создавалась прежде всего для упрощения создания тестов на С++, а также это хороший пример применения интерфейса модуля.
При создании приложений прямое использование управляющих вызовов предпочтительнее.
Однако её можно использовать в приложении с лицензией GPL-2+, либо может быть создана библиотека с лицензией LGPL-2+, с который сможет динамически линковаться даже проприетарное приложение.

Консольный инструмент blksnap
-----------------------------

Консольный инструмент blksnap [#userspace_tools]_ позволяет управлять модулем из командной строки.
Инструмент содержит подробную встроенную помощь.
Со списком команд можно ознакомиться, введя команду ``blksnap --help``. Команда
``blksnap <command name> --help`` позволит получить подробную информацию о параметрах вызова каждой команды.
Этот вариант может быть удобен при создании проприетарного программного обеспечения, так как позволяет не компилироваться с открытым кодом.
В тоже время с помощью инструмента blksnap могут быть созданы скрипты для выполнения резервных копий.
Например, может быть вызван rsync для синхронизации файлов на файловой системе смонтированного образа снапшота и файлов в архиве на файловой системе, поддерживающей сжатие.

Тесты
-----

Для проведения регрессионного тестирования был создан набор тестов [#userspace_tests]_.
На bash написаны тесты с простыми алгоритмами, которые используют консольный инструмент ``blksnap`` для управления модулем.
Более сложные алгоритмы тестирования реализованы на С++.
Документацию [#userspace_tests_doc]_ о них можно найти на репозитории проекта.

References
==========

.. [#btrfs_increment] https://btrfs.wiki.kernel.org/index.php/Incremental_Backup

.. [#userspace_tools] https://github.com/veeam/blksnap/tree/master/tools/blksnap

.. [#userspace_libs] https://github.com/veeam/blksnap/tree/master/lib/blksnap

.. [#userspace_tests] https://github.com/veeam/blksnap/tree/master/tests

.. [#userspace_tests_doc] https://github.com/veeam/blksnap/tree/master/doc

Source code documentation
=========================

.. kernel-doc:: include/uapi/linux/blksnap.h
