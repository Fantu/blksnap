.. SPDX-License-Identifier: GPL-2.0

================================================
Модуль для создания снапшотов блочных устройств
================================================

Introduction
============

На первый взгляд в идее создания снапшотов для блочных устройств нет новизны.
В ядре Linux уже есть механизмы для создания снапшотов.
В состав Device Mapper входит dm-snap, который позволяет создавать снапшоты блочных устройств.
BTRFS поддерживает снапшоты на уровне файловой системы.
У обоих этих вариантов есть недостатки, которые не позволяют использовать их как универсальное средство для создание резервных копий.

Недостатки Device Mapper:
 * На блочных устройства должна быть LVM разметка.
   Если при установке системы логические тома не были созданы, то dm-snap не может быть применён.
 * Для хранения изменений снапшота одного логического тома необходимо зарезервировать фиксированный диапазон секторов на зарезервированном пустом логическом томе.
   Во первых, требуется чтобы в системе было достаточно пространства, незанятого файловой системой, что на реальных серверах встечается редко.
   Во вторых, как правило необходимо создать снапшоты сразу для всех логических томов, что требует разделить между несколькими логическими томами это зарезервированное пространство. Это усложняет управление хранилищем изменений и делает практически невозможным создание согласованного снапшота нескольких логических томов.

Недостатки BTRFS:
 * Очевидно не может быть применён для других файловых систем.
 * Снапшоты создают неизменный образ именно файловой системы, а не блочного устройства.
   Такой снапшот применим только для файлового бэкапа.
   При синхронизации сабволюма снапшота с сабволюмом резервной копии используются значительные системные ресурсы, что приводит к низкой эффективности по сравнению с прямым копированием блочного устройства.
 * Есть возможность получить инкременальный бэкап при синхронизации сабволюмов, но для этого необходимо удерживать на системе снапшот предыдущего цикла бэкапа, что приводит к чрезмерному потреблению дискового пространства.
 * Переполнение снапшота приводит к нарушению работы файловой системы и остановке работы сервера.

Достоинства модуля blksnap:
 * Наличие трекера изменений.
 * Создание снапшотов на уровне блочного устройства.
 * Динамическое выделение пространства для хранения изменеий.
 * Устойчивость к переполнению снапшота.
 * Согласованный снапшот нескольких блочных устройств.

Более подробное описание особенностей в разделе Features.

Перечисленный набор возможностей позволяет достигнуть ключевых целей средства резервного копирования:
 * Простота и универсальность использования.
 * Надёжность.
 * Минимальное потребление системных ресурсов при бэкапе.
 * Минимальное время восстановления или репликации системы целиком.

Таким образом, модуль blksnap является наилучшим средством создания снапшотов для средств резервного копирования.

Features
========

Трекер изменений
----------------

Трекер изменений позволяет определить, какие блоки были изменены за время между последним созданным снапшотом и любым из предыдущих снапшотов.
Обладая картой изменений достаточно произвести копирование только изменившихся блоков, а не перечитывать всё блочное устройтсво полностью.
Позволяет реализовывать логику как инкрементального, так и дифференциального бэкапа.
Инкрементальный бэкап критически важен для больших файловых хранилищ, размер которых может составлять сотни терабайт, а время полного резервного копирования может длится более суток.
На таких серверах использование средств резервного копирования без трекера изменений становится фактически невозможным.

Снапшот на уровне блочного устройства
-------------------------------------

Снапшот на уровне блочного устройства позволяет упростить алгоритм резервного копирования и снизить потребление системных ресурсов.
Позволяет выполнять линейное чтение дискового простанства напрямую, что позволяет достигнуть максимальной скорости чтения при минимальном использовании процессорного времени.
При этом достигается универсальность создания снапшотов для любых блочных устройств вне зависимости от файловой системы, расположенной на ней.
Исключением являются BTRFS, ZFS и кластерные файловые системы.

Динамическое выделение пространства для хранения изменеий
---------------------------------------------------------

Для хранения изменений модуль не требует заранее зарезервированного диапазона блочного устройтсва.
Для хранения изменений снапшота может быть использован произвольный диапазон секторов на любом блочном устройстве.
Размер хранилища изменений может увеличиваться уже после создания снапшота путём добавления новых диапазонов секторов, в том числе на новых блочных устройтсвах.
Это позволяет создавать хранилище изменений в отдельных файлах на файловой системе и увеличивать хранилище изменений по мере необходимости.
Общее хранилище изменений для всех образов блочных устройств снапшота позволяет оптимизировать использование дискового пространства.
При этом поддерживается возможность зарезервировать хранилище изменений необходимого размера до создания снапшота. Такая возможность может быть применима для высоконагруженных систем, для которых время аллокации новых диапазонов секторов может быть слишком длительным.

Устойчивость к переполнению снапшота
------------------------------------

Для создания образов снапшотов блочных устройств модуль хранит блоки оригинального блочного устройства, которые были изменены с момента снятия снапшота.
Для этого модуль перехватывает запросы на запись и считывает блоки, которые должны быть перезаписаны.
Такой алгоритм гарантирует сохранность данных оригинального блочного устройства в случае переполнения снапшота, и даже в случае непредсказуемых критических ошибкок.
Если возникает проблема во время резервного копирования, хранилище изменений освобождается, снапшот закрывается, резервная копия не создаётся, но сервер продолжает работать.

Согласованный снапшот нескольких блочных устройств
--------------------------------------------------

Снапшот создаётся одновременно для всех блочных устройств, для которых создаётся резервная копия, обеспечивая их согласованное состояние.


Algoritms
=========

Overview
--------

Модуль blksnap является фильтром блочного слоя. Он перехватывает все запросы на запись.
Подключение фильтра к блочному устройству выполняется при первом создании снапшорта.
Трекер изменений отмечает все перезаписанные блоки. При создании снапшота доступна информация об истории изменений на блочном устройстве.
Модуль выполняет чтение блоков, которые должны быть перезаписаны, и сохраняет их в хранилище изменений.
При чтении из образа снапшота чтение выполняется либо из оригинального устройства, либо из хранилища изменений.

Трекер изменений
----------------

Для каждого блочного устройства создаётся карта трекера изменений. Один байт этой карты соответствует одному блоку.
Размер блока задаётся параметрами конфигурации модуля: ``tracking_block_minimum_shift`` и ``tracking_block_maximum_count``.
Параметр ``tracking_block_minimum_shift`` ограничивает минимальный размер блока для трекинга, в то время как ``tracking_block_maximum_count`` определяет их максимальное допустимое количество.
Размер блока трекера изменений определяется в зависимости от размера блочного устройства при добавлении устройства под трекинг, то есть при первом снятии снапшота.
Размер блока может должен быть кратен степени двойки.

Байт карты изменений хранит число от 0 до 255. Это номер снапшота, с момента снятия которого были изменения в блоке.
При каждом снятии снапшота номер текущего снапшота увеличивается на единицу.
Этот номер записывается в ячейку карты изменений при записи в блок.
Таким образом, зная номер одного из предыдущих снапшотов и номер последнего снапшота, можно определить по карте изменений, какие блоки были изменены.
Когда номер текущего изменения достигает максимального допустимого значения для карты в 255, при создании следующего снапшота карта изменений обнуляется, а номеру текущего снапшота присваивается значение 1.
Трекер изменений сбрасывается и генерируется новый UUID — уникальный идентификатор поколения снапшотов.
Идентификатор поколения снапшотов позволяет выявлять, что был выполнен сброс трекинга изменений.

У карты изменений есть две копии. Одна копия активная, она отслеживает текущие изменения на блочном устройстве.
Вторая копия доступна для чтения на время, пока удерживается снапшот, и содержит историю до момента снятия снапшота.
Копии синхронизируются в момент снятия снапшота.
После освобождения снапшота вторая копия карты не нужна, но она не освобождается, чтобы не выделять для неё память снова при следующем создании снапшота.

Копирование при записи
----------------------

Копирование данных выполняется блоками, точнее кусками. Термин "кусок" используется, чтобы не путать его с блоками трекера изменений и блоками ввода/вывода.
Кроме того, "кусок" в модуле blksnap означает примерно то же самое, что и "кусок" в модуле dm-snap.

Размер куска определяется параметрами модуля ``chunk_minimum_shift`` и ``chunk_maximum_count``.
Параметр ``chunk_minimum_shift`` ограничивает минимальный размер куска, в то время как ``chunk_maximum_count`` определяет их максимальное допустимое количество.
Размер куска определяется в зависимости от размера блочного устройства в момент снятия снапшота. Размер куска должен быть степенью двойки.
Один кусок описывается структурой ``struct chunk``. Для каждого блочного устройства создаётся массив структур.
Структура содержит всю необходимую информацию для копирования данных куска с оригинального блочного устройства в хранилище изменений.
Эта же информация позволяет отобразить образ снапшота. В структуре расположен семафор, позволяющий обеспечить синхронизацию потоков, обращающихся к одному куску.
На время, пока выполняется чтение данных куска с оригинального блочного устройства, инициировавший запрос записи поток переводится в состояние ожидания.

У блочного уровня есть и другая особенность. Если послать запрос на чтение, а вслед нему послать запрос на запись, то сначала может быть выполнена запись, а лишь затем чтение.
Поэтому алгоритм копирования при записи выполняется синхронно.
При перехвате запроса на запись, выполнение этого запроса будет отложено до тех пор, пока не будут скопированы в хранилище изменений подверженные перезаписи куски.
Но если при перехвате запроса на запись оказывается что записываемый диапазон секторов уже был скопирован в хранилище изменений, то запрос просто пропускается.

Такой алгоритм позволяет эффективно выполнять резервные копии систем с работающими на них Round Robin Database.
Такие базы способны несколько раз перезаписаться за время выполнения резервного копирования системы.
Конечно, ценность резервной копии данных RRD-системы мониторинга можно поставить под сомнение.
Однако часто стоит задача сделать резервную копию всей инфраструктуры предприятия целиком, чтобы в случае проблем восстановить или реплицировать её тоже целиком.

Но есть и недостаток. Так как при перезаписи хотя бы одного сектора производится копирование целого куска, возможна ситуация быстрого заполнения хранилища изменений при записи на блочное устройство данных маленькими порциями в случайном порядке.
Такая ситуация возможна при сильной фрагментации данных на файловой системе.
Но надо учитывать что при такой фрагментации данных производительность систем как правило сильно деградирует.
Поэтому эта проблема не встречается на реальных серверах, хотя легко может быть создана искусственными тестами.

Хранилище изменений
-------------------

Прежде чем рассмотреть, как модуль blksnap организует хранилище изменений, рассмотрим как обстоят дела в других похожих решениях.

BTRFS реализует снапшоты на уровне файловой системы. Если снапшот снят, то при перезаписи файлов запись выполняется в новые блоки.
Старые блоки остаются и используются для отображения снапшота.
Поэтому при переполнении снапшота не остаётся места для сохранения новых актуальных данных и система теряет работоспособность.

Device Mapper реализует поддержку снапшотов с помощью dm-snap. Алгоритм копирования при записи примерно такой же, как у модуля blksnap.
Прежде чем перезаписать данные на оригинальном устройстве, они считываются и сохраняются в специально выделенный диапазон секторов блочного устройства.
На практике это означает, что при снятии снапшота с нескольких блочных устройств нужно иметь несколько или одно пустое блочное устройство, выделить на нём области для каждого блочного устройства, с которого снимается снапшот.
Первая проблема в том, что в системе может не быть свободного дискового пространства для целей хранения изменений.
Если же на диске есть свободное пространство, то возникает вопросы: "А достаточно ли свободного дискового пространства?" и "Как его разделить между блочными устройствами?".
Можно разделить это пространство поровну либо пропорционально размеру. Но нагрузка на разные диски, как правило, распределена неравномерно.
В результате, для одного из блочных устройств происходит переполнение снапшота, в то время как для других всё зарезервированное пространство может оставаться свободным. Получается, что зарезервированное пространство используется неоптимально.

Хранилище изменений модуля blksnap не имеет перечисленных недостатков.
Копирование при записи в хранилище изменений сохраняет старые данные, необходимые для образов снапшотов. Поэтому при переполнении снапшота процесс резервного копирования прерывается, но система сохраняет свою работоспособность без потери данных.
Хранилище изменений общее для всех блочных устройств снапшота. Отпадает необходимость распределять область хранения изменений между блочными устройствами.
Хранилище изменений представляет собой пул областей дискового пространства на разных блочных устройствах. То есть нагрузка по хранению изменений может быть распределена.
Нет необходимости выделять сразу большое дисковое пространство перед снятием снапшота. Уже во время удержания снапшота хранилище изменений может быть расширено.

Благодаря перечисленным возможностям хранилища изменений модуля blksnap для не нужно заранее выделять свободное дисковое пространство.
Достаточно иметь свободное пространство на файловой системе. Области дискового пространства можно аллоцировать с помощью fallocate().
Запросить расположение файла можно с помощью Fiemap Ioctl или Fibmap Ioctl.
К сожалению, не все файловые системы поддерживают работу этих механизмов, но самые распространённые XFS, EXT4 и BTRFS его поддерживают.
Для BTRFS требуется последующее преобразование виртуальных смещений в физические.
При удержании снапшота можно опрашивать его состояние с помощью специального ioctl.
Когда свободное пространство в хранилище изменений заканчивается, модуль уведомляет об этом пользовательский процесс, который может подготовить новую область и передать её модулю для расширения хранилища изменеий.

How to use
==========

В зависимости от потребностей и выбранной лицензии можно выбрать разные варианты управления модулем:
 * Непосредственно через ioctl;
 * Используя статическую С++ библиотеку;
 * Используя консольный инструмент blksnap.

Иcпользование ioctl
-------------------

Модуль ядра предоставляет заголовочный файл ``include/uapi/blksnap.h``.
В нём описаны все доступные ioctl и структуры для взаимодействия с модулем.
Каждый ioctl и структура подробно документированы.
Общий алгоритм вызова управляющих запросов примерно следующий.
 1. ``blk_snap_ioctl_snapshot_create`` инициирует процесс создания снапшота.
 2. ``blk_snap_ioctl_snapshot_append_storage`` позволяет добавит первый диапазон блоков для храниения изменений.
 3. ``blk_snap_ioctl_snapshot_take`` создаёт блочные устройства образов снапшотов блочных устройств.
 4. ``blk_snap_ioctl_snapshot_collect`` и ``blk_snap_ioctl_snapshot_collect_images`` позволяют сопоставить оригинальные блочные устройтсва и соответсвующие им образы снапшотов.
 5. Выполняется чтение образов снапшотов с блочных устройтсв, номера которых были получены при вызове ``blk_snap_ioctl_snapshot_collect_images``. Образы снапшотов поддерживают и операцию записи, поэтому перед резервным копированием можно монтировать файловую систему на образе снапшота и проводить необходимый препроцессинг.
 6. ``blk_snap_ioctl_tracker_collect`` и ``blk_snap_ioctl_tracker_read_cbt_map`` позволяют получить данные трекера изменений. Если в образ снапшота производилась запись, то трекер изменений учитывает это. Поэтому получать данные трекера необходимо после того, как операции записи были завершены.
 7. ``blk_snap_ioctl_snapshot_wait_event`` позволяет отслеживать состояние снапшотов и получать нотификацию о требовании расширения хранилища изменений или переполнении снапшота.
 8. Расширение производится с помощью ``blk_snap_ioctl_snapshot_append_storage`` .
 9. ``blk_snap_ioctl_snapshot_destroy`` освобождает снапшот.
 10. Если после создания резервной копии с данными в бэкапе выполняется постпроцессинг, изменяющий блоки резервной копии, неободимо помечать такие блоки как грязные в таблице трекера изменений. Для этого может быть использован ``blk_snap_ioctl_tracker_mark_dirty_blocks``.
 11. Есть возможность отключить трекер изменений от какого-либо блочного устройтсва. Для этого применяется ``blk_snap_ioctl_tracker_remove``.

Статическая С++-библиотека
--------------------------

Библиотека [#userspace_libs]_ создавалась прежде всего для упрощения создания тестов на С++, а также это хороший пример применения интерфейса модуля.
При создании приложений прямое использование управляющих вызовов предпочтительнее.
Однако её можно использовать непосредственно в приложении с лицензией GPL-2+ или сделать библиотеку с лицензией LGPL-2+, с который будет динамически линковаться проприетарное приложение.

Консольный инструмент blksnap
-----------------------------

Консольный инструмент blksnap [#userspace_tools]_ позволяет управлять модулем из командной строки.
Инструмент содержит подробную встроенную помощь.
Со списком команд можно ознакомиться введя команду ``blksnap --help``.
``blksnap <command name> --help`` позволит получить подробную информацию о параметрах вызова каждой команды.
Этот вариант может быть удобен при создании проприетарного программного обеспечения, так как позволяет не компилироваться с открытым кодом.
В тоже время с помощью инструмента blksnap можно создавать свои скрипты для выполнения резервных копий.
Например, можно вызывать rsync для синхронизации файлов на файловой системе смонтированного снапшота и файлов в архиве на файловой системе, поддерживающей сжатие.

Тесты
-----

Для проведения регрессионного тестирования был создан набор тестов [#userspace_tests]_.
На bash написаны тесты с простыми алгоритмами, которые используют консольный инструмент ``blksnap`` для упралвения модулем.
Более сложные алгоритмы тестирования реализованы на С++.
Документацию [#userspace_tests_doc]_ о них можно найти на репозитории проекта.

References
==========

.. [#userspace_tools] https://github.com/veeam/blksnap/tree/master/tools/blksnap

.. [#userspace_libs] https://github.com/veeam/blksnap/tree/master/lib/blksnap

.. [#userspace_tests] https://github.com/veeam/blksnap/tree/master/tests

.. [#userspace_tests_doc] https://github.com/veeam/blksnap/tree/master/doc

Source code documentation
=========================

.. kernel-doc:: include/uapi/linux/blksnap.h
