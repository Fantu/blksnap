# Создание снапшотов блочных устройств с момощью модуля ядра blksnap

* [Введение](#введение)
* [Возможности модуля](#возможности-модуля)
* [Как это работает](#как-это-работает)
  - [Трекер изменений](#трекер-изменений)
  - [Копирование при записи](#копирование-при-записи)
  - [Хранилище изменений](#хранилище-изменений)
* [Как этим пользоваться](#как-этим-пользоваться)
  - [Иcпользование ioctl](#иcпользование-ioctl)
  - [Статическая С++ библиотека](#статическая-c-библиотека)
  - [Консольный инструмент blksnap](#консольный-инструмент-blksnap)

## Введение
В идее создания снапшотов блочных устройств нет новизны. В ядре Linux уже есть механизмы для создания снапшотов. Прежде всего это Device Mapper, который позволяет создавать персистентные и неперсистентные снапшоты блочных устройств. Есть файловые системы, поддерживающие снапшоты, такие как BTRFS. Есть и другие механизмы, но у всех них есть свои особенности, которые не позволяют использовать их как универсальное средство для создание резервных копий. Именно поэтому разные поставщики средств для резервного копирования предлагают для создания снапшотов свои модули ядра.

Модуль blksnap является частью ядра Linux начиная с версии 6.?(патч находится на рассмотрении на момент редактировния данного документа).
Он обеспечивает создание неперсистентных снапшотов на большинстве современных систем без требования изменения их конфигурации.

## Возможности модуля
В модуле реализован трекер изменений. Он позволяет определить, какие блоки были изменены за время между последним созданным снапшотом и любым из предыдущих снапшотов одного поколения. Это позволяет реализовывать логику как инкрементального, так и дифференциального бэкапа.

Для хранения изменений снапшота может быть использован произвольный диапазон секторов на любом блочном устройстве. Размер хранилища изменений может увеличиваться уже после создания снапшота путём добавления новых диапазонов секторов. Это позволяет создавать хранилище изменений в отдельных файлах на файловой системе, которая может занимать всё пространство блочного устройства и увеличивать хранилище изменений по мере необходимости.

Для создания образов снапшотов блочных устройств модуль хранит блоки оригинального блочного устройства, которые были изменены с момента снятия снапшота. Для этого модуль перехватывает запросы на запись и считывает блоки, которые должны быть перезаписаны. Такой алгоритм гарантирует сохранность данных оригинального блочного устройства в случае переполнения снапшота, и даже в случае непредсказуемых критических ошибкок.

Снапшот создаётся одновременно для нескольких блочных устройств, обеспечивая их согласованное состояние в резервной копии.

Снапшот создаётся именно для блочного устройства, а не для состояния файловой системы. Это позволяет использовать его для случаев, когда блочное устройство используется без файловой системы, файловая система не поддерживается или поддерживается не полностью.

Перечисленный набор возможностей позволяет использовать модуль для целей резервного копирования и репликации всего содержимого дисковой подсистемы целиком. В результате значительно упрощается восстановление системы из резервной копии.

Кроме самого модуля ядра, был разработан набор сопутствующего ПО под лицензиями GPL и LGPL.
Консольный инструмент и С++-библиотека для управления модулем могут быть использованы для интеграции с другими проектами.
Набор тестов позволяет проводить регрессионное тестирование модуля blksnap в составе ядра.

## Как это работает
Модуль blksnap является фильтром блочного слоя. Он перехватывает все запросы на запись.

Подключение фильтра к блочному устройству выполняется при первом создании снапшорта.

Трекер изменений отмечает все перезаписанные блоки. При создании снапшота доступна информация об истории изменений на диске.

Модуль выполняет чтение блоков, которые должны быть перезаписаны, и сохраняет их в хранилище изменений. При чтении из образа снапшота чтение выполняется либо из оригинального устройства, либо из хранилища изменений.

### Трекер изменений
Для каждого блочного устройства создаётся карта трекера изменений. Один байт этой карты соответствует одному блоку.
Размер блока задаётся параметрами модуля: tracking_block_minimum_shift, tracking_block_maximum_shift и tracking_block_maximum_count. Параметр tracking_block_minimum_shift ограничивает минимальный размер блока для трекинга, в то время как tracking_block_maximum_count определяет их максимальное допустимое количество. Размер блока трекера изменений определяется в зависимости от размера блочного устройства при добавлении устройства под трекинг, то есть при первом снятии снапшота. Размер блока должен быть кратен степени двойки. Однако размер блока не должен превышать tracking_block_maximum_shift. Если размер блока достигает этого значения, то их количесто может превысить tracking_block_maximum_count.

Байт карты изменений хранит число от 0 до 255. Это номер снапшота, с момента снятия которого были изменения в блоке. При каждом снятии снапшота номер текущего снапшота увеличивается на единицу. Этот номер записывается в ячейку карты изменений при записи в блок. Таким образом, зная номер одного из предыдущих снапшотов и номер последнего снапшота, можно определить по карте изменений, какие блоки были изменены. Когда номер текущего изменения достигает максимального допустимого значения для карты в 255, при создании следующего снапшота карта изменений обнуляется, а номеру текущего снапшота присваивается значение 1. Трекер изменений сбрасывается и генерируется новый UUID — уникальный идентификатор поколения снапшотов. Идентификатор поколения снапшотов позволяет выявлять, что был выполнен сброс трекинга изменений.

У карты изменений есть две копии. Одна копия активная, она отслеживает текущие изменения на блочном устройстве. Вторая копия доступна для чтения на время, пока удерживается снапшот, и содержит историю до момента снятия снапшота. Копии синхронизируются в момент снятия снапшота. После освобождения снапшота вторая копия карты не нужна, но она не освобождается, чтобы не выделять для неё память снова при следующем создании снапшота.

### Копирование при записи
Копирование данных выполняется блоками, точнее кусками. Термин "кусок" используется, чтобы не путать его с блоками трекера изменений и блоками ввода/вывода. Кроме того, "кусок" в модуле blksnap означает примерно то же самое, что и "кусок" в модуле dm-snap.

Размер куска определяется параметрами модуля chunk_minimum_shift, chunk_maximum_shift и chunk_maximum_count. Параметр chunk_minimum_shift ограничивает минимальный размер куска, в то время как chunk_maximum_count определяет их максимальное допустимое количество. Размер куска определяется в зависимости от размера блочного устройства в момент снятия снапшота. Размер куска должен быть степенью двойки. Однако размер куска не должен превышать chunk_maximum_shift. Если размер куска достигает этого значения, то их количесто может превысить chunk_maximum_count.

Один кусок описывается структурой &struct chunk. Для каждого блочного устройства создаётся массив структур. Структура содержит всю необходимую информацию для копирования данных куска с оригинального блочного устройства в хранилище изменений. Эта же информация позволяет отобразить образ снапшота. В структуре расположен семафор, позволяющий обеспечить синхронизацию потоков, обращающихся к одному куску. На время, пока выполняется чтение данных куска с оригинального блочного устройства, инициировавший запрос записи поток переводится в состояние ожидания.

У алгоритма копирования при записи есть недостаток. Так как при перезаписи хотя бы одного сектора производится копирование целого куска, возможна ситуация быстрого заполнения хранилища изменений при записи на блочное устройство данных маленькими порциями в случайном порядке. Такая ситуация возможна при сильной фрагментации данных на файловой системе. При этом производительность машины сильно деградирует и без модуля blksnap. Поэтому эта проблема не встречается на реальных серверах, хотя легко может быть создана искусственными тестами.

### Хранилище изменений
Прежде чем рассмотреть, как модуль blksnap организует хранилище изменений, рассмотрим как обстоят дела в других похожих решениях.

BTRFS реализует снапшоты на уровне файловой системы. Если снапшот снят, то при перезаписи файлов запись выполняется в новые блоки. Старые блоки остаются и используются для образа снапшота файловой системы. Поэтому при переполнении снапшота не остаётся места для сохранения новых актуальных данных и система теряет работоспособность.

Device Mapper реализует поддержку снапшотов с помощью dm-snap. Он реализует логику снапшота блочного устройства. Алгоритм копирования при записи примерно такой же, как у модуля blksnap. Прежде чем перезаписать данные на оригинальном устройстве, они считываются и сохраняются в специально выделенное для этих целей блочное устройство. На практике это означает, что при снятии снапшота с нескольких блочных устройств нужно иметь несколько или одно пустое блочное устройство, выделить на нём области для каждого устройства, с которого снимается снапшот. Первая проблема в том, что в системе может не быть свободного дискового пространства для целей хранения изменений. Если же на диске есть свободное пространство, то возникает вопрос: "А достаточно ли свободного дискового пространства, и как его разделить между блочными устройствами?". Можно разделить это пространство поровну либо пропорционально размеру. Но нагрузка на разные диски, как правило, распределена неравномерно. В результате, для одного из блочных устройств происходит переполнение снапшота, в то время как для других всё зарезервированное пространство может оставаться свободным. Получается, что зарезервированное пространство используется неоптимально.

Хранилище изменений модуля blksnap не имеет перечисленных недостатков.
1. Копирование при записи в хранилище изменений сохраняет старые данные, необходимые для образов снапшотов. Поэтому при переполнении снапшота образы снапшотов становятся неконсистентными. Процесс резервного копирования прерывается, но система сохраняет свою работоспособность без потери данных.
2. Хранилище изменений общее для всех блочных устройств снапшота. Отпадает необходимость распределять область хранения изменений между блочными устройствами.
3. Хранилище изменений представляет собой пул областей дискового пространства на разных блочных устройствах. То есть нагрузка по хранению изменений может быть распределена.
4. Нет необходимости выделять сразу большое дисковое пространство перед снятием снапшота. Уже во время удержания снапшота хранилище изменений может быть расширено.

Благодаря перечисленным возможностям хранилища изменений модуля blksnap для не нужно заранее выделять свободное дисковое пространство. Достаточно иметь свободное пространство на файловой системе. Области дискового пространства можно аллоцировать с помощью fallocate(). К сожалению, не все файловые системы поддерживают этот системный вызов, но самые распространённые XFS и EXT4 его поддерживают (а также BTRFS, но требуется преобразование виртуальных смещений в физические). При удержании снапшота можно опрашивать его состояние с помощью специального ioctl. Когда свободное пространство в хранилище изменений заканчивается, модуль уведомляет об этом пользовательский процесс, который может подготовить новую область и передать её модулю для расширения хранилища изменеий.

## Как этим пользоваться
В зависимости от потребностей и выбранной лицензии можно выбрать разные варианты управления модулем:
1. непосредственно через ioctl;
2. используя статическую С++ библиотеку;
3. используя консольный инструмент blksnap.

### Иcпользование ioctl
В состав ядра входят заголовочные файлы uapi/linux/blk-filter.h и uapi/linux/blksnap.h. Управление фильтром выполняется с помощью ioctl: BLKFILTER_ATTACH, BLKFILTER_DETACH, BLKFILTER_CTL. Они позволяют подключать фильтр к блочному устройству, отклчючать его и передавать фильтру команды управления. Кроме того,  модуль blksnap создаёт файл /dev/blksnap-control. С его помощью модулю передаются команды управления снапшотами. Подробное описание интерфейса фильтра блочного устройтсва в документации ядра Documentation/block/blkfilter.rst или [онлайн](https://www.kernel.org/doc/html/latest/block/blkfilter.html). Описание интерфейса модуля blksnap в документации ядра Documentation/block/blksnap.rst или [онлайн](https://www.kernel.org/doc/html/latest/block/blksnap.html).

### Статическая C++ библиотека
Библиотека создавалась прежде всего для упрощения создания тестов на С++. Ещё это хороший пример применения ioctl-интерфейса модуля. Можно использовать её непосредственно в приложении с лицензией GPL-2+ или сделать библиотеку с лицензией LGPL-2+, с который будет динамически линковаться проприетарное приложение.

Интерфейс библиотеки достаточно прост. Специальной документации не создавалось.
Краткое описание назначения ключевых классов:
* Класс blksnap::CBlksnap (include/blksnap/Blksnap.h) является тонкой С++-обёрткой для ioctl-интерфейса модуля ядра. Вам может быть достаточно абстракции на этом уровне.
* Интерфейс blksnap::ISession (include/blksnap/Session.h). Его статический метод Create() создаёт объект снапшота и удерживает его. Снапшот освобождается при освобождении этого объекта. Объект содержит в себе реализацию алгоритма выделения новых порций для хранилища изменений и обработку событий от модуля. Для работы достаточно создать сессию и с помощью вызова GetImageDevice() получить имя блочного устройства образа снапшота. Очень подойдёт для быстрого создания прототипа приложения.
* Интерфейс blksnap::ICbt (include/blksnap/Cbt.h) позволяет получить доступ к данным трекера изменений.
* Файл include/blksnap/Service.h содержит функцию получения версии модуля ядра и может содержать прочую функциональность для отладки модуля.

### Консольный инструмент blksnap
Инструмент содержит подробную встроенную справку. Вызов "blksnap --help" позволяет получить список команд. При запросе "blksnap \<command name\> --help" выводится описание команды. В планах создание man страниц.
