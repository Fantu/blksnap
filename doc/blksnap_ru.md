# blksnap - модуль для создания снапшотов блочных устройств

## Введение
В идеи создания снапшотов для блочных устройств нет новизны. Даже в ядре Linux уже есть механизмы для создания снапшотов блочных устройств.
Прежде всего это Device Mapper, который позволяет создавать персистентные и неперсистентные снапшоты блочных устройств. Есть файловые системы, поддерживающие снапшоты, такие как BTRFS. Есть и другие, но у всех них есть свои особенности. Эти особенности не позволяют использовать их как универсальное средство для создание резервных копий. Именно поэтому разные поставщики средств для резервного копирования предлагают для создания снапшотов свои модули ядра. К сожалению ни один из этих модулей не соответствует требованиям восходящего потока ядра Linux.
Модуль blksnap создавался именно с целью предложения его в восходящий поток. Он обеспечивает создание неперсистентных снапшотов на большинстве современных систем без требования изменения их конфигурации.

## Возможности модуля blksnap
В модуле реализован трекер изменений. Он позволяет определить, какие  блоки были изменены за время между последним созданным снапшотом и любым из предыдущих снапшотов одного поколения. Это позволяет реализовывать логику как инкрементального, так и дифференциального бэкапа.

Для хранения изменений снапшота может быть использован произвольный диапазон секторов на любом блочном устройстве. Размер хранилища изменений может увеличиваться уже после создания снапшота путём добавления новых диапазонов секторов. Это позволяет создавать хранилище изменений в отдельных файлах на файловой системе, которая может занимать всё пространство блочного устройства и увеличивать хранилище изменений по мере необходимости.

Для создания образов снапшотов блочных устройств модуль хранит блоки оригинального блочного устройства, которые были изменены с момента снятия снапшота. Для этого модуль перехватывает запросы на запись и считывает блоки, которые должны быть перезаписаны. Такой алгоритм гарантирует сохранность данных оригинального блочного устройства в случае переполнения снапшота и даже в случае непредсказуемых критических ошибкок.

Снапшот создаётся одновременно для нескольких блочных устройств, обеспечивая их согласованное состояние в резервной копии.

Снапшот создаётся именно для блочного устройства, а не для состояния файловой системы. Это позволяет использовать его для случаев, когда блочное устройство используется без файловой системы, файловая система не поддерживается или поддерживается не полностью.

Перечисленный набор возможностей позволяет использовать его для целей резервного копирования и репликации всего содержимого дисковой подсистемы целиком. В результате значительно упрощается восстановление системы из резервной копии.

Кроме самого модуля ядра, был разработан набор сопутствующего ПО под лицензией GPL и LGPL.
Консольный инструмент и С++ библиотека для управления модулем могут быть использованы для интеграции с другими проектами.
Набор тестов позволит провести регрессионное тестирование после изменений модуля после исправлений ошибок или после добавления новых возможностей.
Разрабатываемая документация призвана сделать изучение модуля более комфортным.

## Как это работает
Модуль blksnap является фильтром блочного слоя. Он перехватывает все запросы на запись.
Подключение фильтра к блочному устройству выполняется при первом создании снапшорта.
Трекер изменений отмечает все перезаписанные блоки. При создании снапшота доступна информация об истории изменений на диске.
Модуль выполняет чтение блоков, которые должны быть перезаписаны, и сохраняет их в хранилище изменений. При чтении из образа снапшота чтение выполняется либо из оригинального устройства либо из хранилища изменений.

### Трекер изменений
Для каждого блочного устройства создаётся карта трекера изменений. Один байт это карты соответствует одному блоку. Размер блока задаётся параметрами конфигурации модуля: tracking_block_minimum_shift и tracking_block_maximum_count. Параметр tracking_block_minimum_shift ограничивает минимальный размер блока для трекинга, в то время как tracking_block_maximum_count определяет их максимальное допустимое количество. Значения по умолчанию для этих параметров определяются объявлениями конфигурации модуля: CONFIG_BLK_SNAP_TRACKING_BLOCK_MINIMUM_SHIFT и CONFIG_BLK_SNAP_TRACKING_BLOCK_MAXIMUM_COUNT. Размер блока трекера изменений определяется в зависимости от размера блочного устройства при добавлении устройства под трекинг, то есть при первом снятии снапшота. Размер блока может должен быть кратен степени двойки.

Байт карты изменений хранит число от 0 до 255. Это номер снапшота, с момента снятия которого были изменения в блоке. При каждом снятии снапшота номер текущего снапшота увеличивается на единицу. Этот номер записывается в ячейку карты изменений при записи в блок. Таким образом, зная номер одного из предыдущих снапшотов и номер последнего, можно определить по карте изменений какие блоки были изменены. Когда номер текущего изменения достиг максимального допустимого значения для карты в 255, при создании следующего снапшота карта изменений обнуляется, а номеру текущего снапшота присваивается значение 1. Трекер изменений сбрасывается и генерируется новый UUID - уникальный идентификатор поколения снапшотов. Идентификатор поколения снапшотов позволяет выявлять, что был выполнен сброс трекинга изменений.

У карты изменений есть две копии. Одна активная, и отслеживает текущие изменения на блочном устройстве. Вторая доступна для чтения на время пока удерживается снапшот, и содержит историю до момента снятия снапшота. Копии синхронизируются в момент снятия снапшота. После освобождения снапшота вторая копия карты не нужна, но она не освобождается, чтобы не выделять для неё память снова при следующем создании снапшота.

### Копирование при записи
Копирование данных выполняется блоками, точнее кусками. Термин "кусок" используется чтобы не путать его с блоками трекера изменений и блоками ввода/вывода. Кроме того, "кусок" в модуле blksnap означает примерно тоже самое что и "кусок" в модуле dm-snap.
Размер куска определяется параметрами модуля chunk_minimum_shift и chunk_maximum_count. Параметр chunk_minimum_shift ограничивает минимальный размер куска, в то время как chunk_maximum_count определяет их максимальное допустимое количество. Значения по умолчанию для этих параметров определяются объявлениями конфигурации модуля: CONFIG_BLK_SNAP_CHUNK_MINIMUM_SHIFT и CONFIG_BLK_SNAP_CHUNK_MAXIMUM_COUNT. Размер куска определяется в зависимости от размера блочного устройства в момент снятия снапшота. Размер куска должен быть  степенью двойки.

Один кусок описывается структурой &struct chunk. Для каждого блочного устройства создаётся массив структур. Структура содержит всю необходимую информацию для копирования данных куска с оригинального блочного устройства в хранилище изменений. Эта же информация позволяет отобразить образ снапшота. В структуре расположен семафор, позволяющий обеспечить синхронизацию потоков, обращающихся к одному куску. На время пока выполняется чтение данных куска с оригинального блочного устройства, инициировавший запрос записи поток переводится в состояние ожидания.

Особенность фильтра блочного слоя в том, что при перехвате запроса ввода/вывода нельзя выполнять синхронные запросы ввода/вывода. Синхронные запросы могут быть причиной переполнения стека в случае рекурсивного вызова submit_bio_noacct(), а также увеличивают шанс возникновения ситуации взаимной блокировки. Поэтому перед тем ка вызвать функцию обратного вызова фильтра инициализируется переменная current->bio_list, а функция submit_bio_noacct() в этом случае добавляет запрос ввода/вывода в этот связанные список. После выполнения функции обратного вызова обработки запроса, из списка current->bio_list все запросы извлекаются и для них вызывается submit_bio_noacct(). Поэтому алгоритм копирования при записи выполняется асинхронно.

У блочного уровня есть другая особенность. Если послать запрос на чтение, а в след нему послать запрос на запись, то сначала может быть выполнена запись, а лишь затем чтение. Даже использование флагов REQ_SYNC и REQ_PREFLUSH не обеспечивает корректного поведения.

Благодаря этим особенностям текущая реализация предполагает повторое вхождение в обработчик. При первом вызове функции обратного вызова блокируется семафор куска и формируется связанный список запросов, читающих перезаписываемый кусок, после чего блочный уровень передаёт их на выполение и снова вызывает функцию обратного вызова фильтра. При втором вызове функции обратного вызова при попытке заблокировать семафор куска процесс блокируется до тех пор, пока не завершиться чтение данных куска с оригинальгого блочного устройства. Если же при выполнении функции обратного вызова становится ясно, что данные куска уже были скопированы, то запрос на запись просто пропускается без каких либо промедлений.

Такой алгоритм позволяет эффективно выполнять резервные копии систем с работающими на них Round Robin Database [RRD](https://www.loriotpro.com/Products/On-line_Documentation_V5/LoriotProDoc_EN/V22-RRD_Collector_RRD_Manager/V22-A1_Introduction_RRD_EN.htm). Такие базы способны несколько раз перезаписаться за время выполнения резервного копирования машины. Конечно ценность резервной копии данных RRD системы мониторинга можно поставить под сомнение. Однако часто стоит задача сделать резервную копию всей инфраструктуры предприятия полностью, чтобы в случае проблем восстановить или реплизировать её тоже целиком.

Но есть и недостаток. Так как при перезаписи хотя бы одного сектора, производится копирование целого куска, то возможна ситуация быстрого заполнения хранилища изменений при записи на блочное устройство данных маленькими порциями в случайном порядке. Такая ситуация возможна при сильной фрагментации данных на файловой системе. При этом производительность  машины сильно деградирует и без модуля blksnap. Поэтому эта проблема не встречается на реальных серверах, хотя легко может быть создана искусственными тестами.

### Область для храниения изменений

## Как этим пользоваться

## Что дальше
