# Снапшоты блочных устройств с помощью модуля ядра blksnap

* [Введение](#введение)
* [Возможности модуля](#возможности-модуля)
* [Как это работает](#как-это-работает)
  - [Трекер изменений](#трекер-изменений)
  - [Копирование при записи](#копирование-при-записи)
  - [Хранилище изменений](#хранилище-изменений)
* [Как этим пользоваться](#как-этим-пользоваться)
  - [Иcпользование ioctl](#иcпользование-ioctl)
  - [Статическая С++ библиотека](#статическая-c-библиотека)
  - [Консольный инструмент blksnap](#консольный-инструмент-blksnap)
  - [Регрессионные тесты](#регрессионные-тесты)
* [Лицензия](#лицензия)

## Введение

В идее создания снапшотов блочных устройств нет новизны. В ядре Linux уже есть механизмы для создания снапшотов. Прежде всего это Device Mapper, который позволяет создавать персистентные и неперсистентные снапшоты блочных устройств. Есть файловые системы, поддерживающие снапшоты, такие как BTRFS. Есть и другие механизмы, но у всех них есть свои особенности, которые не позволяют использовать их как универсальное средство для создание резервных копий. Именно поэтому разные поставщики средств для резервного копирования предлагают для создания снапшотов свои модули ядра.

Модуль blksnap является частью ядра Linux начиная с версии 6.?(патч находится на рассмотрении на момент редактировния данного документа).
Он обеспечивает создание неперсистентных снапшотов на большинстве современных систем без требования изменения их конфигурации.

## Возможности модуля

В модуле реализован трекер изменений. Он позволяет определить, какие блоки были изменены за время между последним созданным снапшотом и любым из предыдущих снапшотов одного поколения. Это позволяет реализовывать логику как инкрементального, так и дифференциального бэкапа.

Для создания образов снапшотов блочных устройств модуль хранит блоки оригинального блочного устройства, которые были изменены с момента снятия снапшота. Модуль гарантирует сохранность данных оригинального блочного устройства в случае переполнения снапшота, и даже в случае непредсказуемых критических ошибкок.

Снапшот создаётся одновременно для нескольких блочных устройств, обеспечивая их согласованное состояние в резервной копии.

Снапшот создаётся именно для блочного устройства, а не для состояния файловой системы. Это позволяет использовать его для случаев, когда блочное устройство используется без файловой системы, файловая система не поддерживается или поддерживается не полностью.

Перечисленный набор возможностей позволяет использовать модуль для целей резервного копирования и репликации всего содержимого дисковой подсистемы целиком. В результате значительно упрощается восстановление системы из резервной копии.

## Как это работает

Модуль blksnap является фильтром блочного слоя. Он перехватывает все запросы на запись. Подключение фильтра к блочному устройству выполняется при первом создании снапшорта.
Трекер изменений отмечает все перезаписанные блоки. При создании снапшота от трекера изменений доступна информация об истории изменений на блочном устройстве.
При перехвате запроса на запись оригинального устройтсва, модуль выполняет чтение блоков, которые должны быть перезаписаны, и сохраняет их в хранилище изменений. При чтении из образа снапшота чтение выполняется либо из оригинального устройства, либо из хранилища изменений.

### Трекер изменений

Для каждого блочного устройства создаётся карта трекера изменений. Один байт этой карты соответствует одному блоку.
Размер блока задаётся параметрами модуля: tracking_block_minimum_shift, tracking_block_maximum_shift и tracking_block_maximum_count. Параметр tracking_block_minimum_shift ограничивает минимальный размер блока для трекинга, в то время как tracking_block_maximum_count определяет их максимальное допустимое количество. Размер блока трекера изменений определяется в зависимости от размера блочного устройства при добавлении устройства под трекинг, то есть при первом снятии снапшота. Размер блока должен быть кратен степени двойки. Однако размер блока не должен превышать tracking_block_maximum_shift. Если размер блока достигает этого значения, то их количесто может превысить tracking_block_maximum_count.

Байт карты изменений хранит число от 0 до 255. Это номер снапшота, с момента снятия которого были изменения в блоке. При каждом снятии снапшота номер текущего снапшота увеличивается на единицу. Этот номер записывается в ячейку карты изменений при записи в блок. Таким образом, зная номер одного из предыдущих снапшотов и номер последнего снапшота, можно определить по карте изменений, какие блоки были изменены. Когда номер текущего изменения достигает максимального допустимого значения для карты в 255, при создании следующего снапшота карта изменений обнуляется, а номеру текущего снапшота присваивается значение 1. Трекер изменений сбрасывается и генерируется новый UUID — уникальный идентификатор поколения снапшотов. Идентификатор поколения снапшотов позволяет выявлять, что был выполнен сброс трекинга изменений.

Есть два экземпляра карты трекера изменений. Одна карта активная, она отслеживает текущие изменения на блочном устройстве. Вторая карта доступна для чтения на время, пока удерживается снапшот и содержит историю до момента снятия снапшота. Карты синхронизируются в момент снятия снапшота. После освобождения снапшота вторая карта не используется.

### Копирование при записи

Копирование данных выполняется блоками, точнее кусками. Термин "кусок" используется, чтобы не путать его с блоками трекера изменений и блоками ввода/вывода. Кроме того, "кусок" в модуле blksnap означает примерно то же самое, что и "кусок" в модуле dm-snap.

Размер куска определяется параметрами модуля chunk_minimum_shift, chunk_maximum_shift и chunk_maximum_count. Параметр chunk_minimum_shift ограничивает минимальный размер куска, в то время как chunk_maximum_count определяет их максимальное допустимое количество. Размер куска определяется в зависимости от размера блочного устройства в момент снятия снапшота. Размер куска должен быть степенью двойки. Однако размер куска не должен превышать chunk_maximum_shift. Если размер куска достигает этого значения, то их количесто может превысить chunk_maximum_count.

Один кусок описывается структурой "struct chunk". Для каждого блочного устройства создаётся массив структур. Структура содержит всю необходимую информацию для копирования данных куска с оригинального блочного устройства в хранилище изменений. Эта же информация позволяет отобразить образ снапшота. В структуре расположен семафор, позволяющий обеспечить синхронизацию потоков, обращающихся к одному куску. На время, пока выполняется чтение данных куска с оригинального блочного устройства, инициировавший запрос записи поток переводится в состояние ожидания.

У алгоритма копирования при записи есть недостаток. Так как при перезаписи хотя бы одного сектора производится копирование целого куска, возможна ситуация быстрого заполнения хранилища изменений при записи на блочное устройство данных маленькими порциями в случайном порядке. Такая ситуация возможна при сильной фрагментации данных на файловой системе. При этом производительность машины сильно деградирует и без модуля blksnap. Поэтому эта проблема не встречается на реальных серверах, хотя легко может быть создана искусственными тестами.

### Хранилище изменений

Для одного снапшота создаётся одно, общее для всех блочных устройств снапшота, хранилище изменений.
Хранилище изменений снапшота может использовать:
- файл на обычной файловой системе;
- блочное устройство;
- файл на tmpfs.

Файл или блочное устройство должны открываться в флагом O_EXCL, чтобы обеспечить эксклюцивный доспуп модуля к данным.

#### Файл на обычной файловой системе

Файл на обычной файловой системе может быть применён для большинства систем. Для файловых систем, поддерживающих fallocate(), доступно динамическое увеличение хранилища изменений. Нет необходимости выделять файл большого размера перед созданием снапшота. Модуль ядра сам увеличи его размер по мере необходимости, но в рамках заданного ограничения.
Однако файл на обычной файловой системе не может быть применён в случае, если он расположен на блочном устройстве, для которого создаётся снапшот. Это означает, что на системе должна быть файловая система, которая не участвует в резервном копировании.

#### Блочное устройство

Такой вариант хранилища изменений позволяет получить максимально возможную производительность, но требует зарезервированного дискового пространства.
Эксклюзивный доступ к блочному устройству гарантирует, что на нём нет смонтированных файловых систем. Динамическое увеличение хранилища изменений в этом случае не функционирует. Хранилище ограничено одним блочным устройтсвом.

#### Файл на tmpfs

Файл на tmpfs может быть применён в случае, если нет свободного дискового пространства и все файловые системы участвуют в резервном копировании. В этом случае, хранилище изменений располагается в виртуальной памяти, то есть в ОЗУ и файле (разделе) подкачки. Для малонагруженных систем такой вариант может быть приемлем. Высоконагруженным серверам может потребоваться раздел подкачки довольно большого размера, иначе виртуальной памяти может быть недостаточно для храниения изменений, что может привести к переполнению снапшота.

## Как этим пользоваться

Кроме самого модуля ядра, был разработан набор сопутствующего ПО под лицензиями GPL и LGPL.
Консольный инструмент и С++-библиотека для управления модулем могут быть использованы для интеграции с другими проектами.

В зависимости от потребностей и выбранной лицензии можно выбрать разные варианты управления модулем:
1. непосредственно через ioctl;
2. используя статическую С++ библиотеку;
3. используя консольный инструмент blksnap.

### Иcпользование ioctl

В состав ядра входят заголовочные файлы uapi/linux/blk-filter.h и uapi/linux/blksnap.h. Управление фильтром выполняется с помощью ioctl: *BLKFILTER_ATTACH*, *BLKFILTER_DETACH*, *BLKFILTER_CTL*. Они позволяют подключать фильтр к блочному устройству, отклчючать его и передавать фильтру команды управления. Кроме того,  модуль blksnap создаёт файл /dev/blksnap-control. С его помощью модулю передаются команды управления снапшотами. Подробное описание интерфейса фильтра блочного устройтсва в документации ядра Documentation/block/blkfilter.rst или [онлайн](https://www.kernel.org/doc/html/latest/block/blkfilter.html). Описание интерфейса модуля blksnap в документации ядра Documentation/block/blksnap.rst или [онлайн](https://www.kernel.org/doc/html/latest/block/blksnap.html).

### Статическая C++ библиотека

Библиотека создавалась для упрощения создания тестов на С++. Библиотека является примером применения ioctl-интерфейса модуля.

#### Класс blksnap::CTracker

Класс *blksnap::CTracker* из ([include/blksnap/Tracker.h](../include/blksnap/Tracker.h)) является тонкой С++-обёрткой для интерфейса фильтра блочного устройства, который реализован в ядре в виде ioctl:
- *BLKFILTER_ATTACH*
- *BLKFILTER_DETACH*
- *BLKFILTER_CTL*.

Методы класса:
- *Attach* - подключает фильтр блочного устройства 'blksnap'
- *Detach* - отключает фильтр
- *CbtInfo* - предоставляет состояние трекера изменений для блочного устройства
- *ReadCbtMap* - читает таблицу изменений блочного устройства
- *MarkDirtyBlock* - задаёт 'грязные блоки' трекера изменений
- *SnapshotAdd* - добавляет блочное устройство в снапшот
- *SnapshotInfo* - позволяет получить статус снапшота блочного устройства.

#### Класс blksnap::CSnapshot

Класс *blksnap::CSnapshot* из ([include/blksnap/Snapshot.h](../include/blksnap/Snapshot.h)) это тонкая С++-обёртка для интерфейса упралвения модулем blknsnap.
Реализует вызовы ioctl:
- *IOCTL_BLKSNAP_VERSION*
- *IOCTL_BLKSNAP_SNAPSHOT_CREATE*
- *IOCTL_BLKSNAP_SNAPSHOT_COLLECT*
- *IOCTL_BLKSNAP_SNAPSHOT_TAKE*
- *IOCTL_BLKSNAP_SNAPSHOT_DESTROY*
- *IOCTL_BLKSNAP_SNAPSHOT_WAIT_EVENT*.

Статические методы класса:
- *Collect* - позволяет получить список UUID всех снапшотов модуля blksnap
- *Version* - запршивает версию модуля
- *Create* - создаёт экземпляр класса *blksnap::CSnapshot*, при этом модуль создаёт снапшот, в который можно добавлять устройства
- *Open* - создаёт экземпляр класса *blksnap::CSnapshot* для существующего снапшота по его UUID.

Методы класса:
- *Take* - снимает снапшот
- *Destroy* - уничтожает снапшот
- *WaitEvent* - позволяет получать события об изменении состояния модуля
- *Id* - запрашивает у экземпляра класса UUID снапшота.

#### Класс blksnap::ISession

Класс *blksnap::ISession* ([include/blksnap/Session.h](../include/blksnap/Session.h)) создаёт сессию снапшота.
Статический метод класса *Create* создаёт экземпляр класса, который создаёт снимает и удерживает санпшот. Класс содержит рабочий поток, который проверяет состояние снапшота и при получении событий сохраняет их в очередь. Метод *GetError* позволяет прочитать сообщение из этой очереди. Деструктор класса уничтожает снапшот.

#### Класс blksnap::ICbt

Класс *blksnap::ICbt* из ([include/blksnap/Cbt.h](../include/blksnap/Cbt.h)) позволяет получить доступ к данным трекера изменений.
Статический метод *Create* создаёт объект для взаимодействия с трекером изменений блочного устройтсва.

Метод класса:
- *GetCbtInfo* - предоставляет информацию о текущем состоянии трекера изменений для блочного устройства
- *GetCbtData* - позволяют прочитать таблицу изменений
- *GetImage* - предоставлят имя блочного устройтсва образа снапшота
- *GetError* - позволяет проверить состояние снапшота блочного устройства.

#### Структура blksnap::SRange

Структура *blksnap::SRange* ([include/blksnap/Sector.h](../include/blksnap/Sector.h)) описывает область блочного устройства, объединяет смещение от начала блочного устройтсва и размер области в виде количества секторов.

#### blksnap::Version

Функция *blksnap::Version* из ([include/blksnap/Service.h](include/blksnap/Service.h)) позволяет получить версию модуля ядра.

### Консольный инструмент blksnap

Инструмент содержит подробную встроенную справку. Вызов "blksnap --help" позволяет получить список команд. При запросе "blksnap \<command name\> --help" выводится описание команды. Страница [man](./blksnap.8) также может быть полезна. Пользуйтесь документацией встроенной в инструмент.

### Регрессионные тесты

Набор тестов позволяет проводить регрессионное тестирование модуля blksnap в составе ядра. Тесты созданы наскриптах bash и на С++.
Тесты на скриптах bash довольно просты. Они проверяют основной базовый функционал. Взаимодействие с модулем ядра осуществляется с помощью инструмента blksnap.
Доступна документация на С++ тесты:
- [boundary](./tests/boundary_ru.md)
- [corrupt](./tests/corrupt_ru.md)

## Лицензия

Модуль ядра, как и ядро Linux имеет лицензию GPL-2.
Консольный инструмент blksnap имеет лицензию GPL-2+.
Библиотеки имеют лицензию LGPL-3+.
